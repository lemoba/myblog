## 高并发和大流量解决方案考点

> 如何解决网站大流量与高并发解决方案？

### 1. 高并发架构相关概念：

**并发**: 并发是指宏观上在**一段时间内**能同时运行多个程序。这些程序宏观上是同时发生的，但微观上是交替发生的。操作系统通过引入进程和线程，使得程序能够并发运行。

**QPS**：每秒钟请求或查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)

**吞吐量**：单位时间内处理的请求数量(通常由QPS与并发数决定)

**响应时间**：从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms，这个100ms就是系统的响应时间。

**PV**：综合浏览量(Page View)，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量。同一个人浏览网站同一个页面，只记作一次PV。

**UV**：独立访客(UniQue Visitor)，即一定时间范围内相同访客多次访问网站，只计算为1个独立访客。

**带宽**：计算带宽大小需关注两个指标，峰值流量和页面的平均大小

**日网站带宽 = PV / 统计时间(换算到秒) * 平均页面大小(单位kb) * 8**

**QPS不等于 并发连接数**

QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量

**峰值每秒请求数(QPS) = (总PV数 * 80 %) / (6小时秒数 *20%)**

**压力工具测试工具：ab**  

ab -c 100 -n 5000 url

### 2. 优化方案

* **QPS分类**
  * QPS <= 50：不需要操作
  * 100 <= QPS < 800 ：数据库缓存、数据库的负载均衡
  * 800 <= QPS < 1000：CND加速，负载均衡
  * 1000 <= QPS < 2000 用缓存中间件、静态HTML缓存
  * QPS >= 2000：业务分离，分布式存储
* **流量优化**
  * 防盗链处理

* **前端优化**

  * 减少http请求

  * 添加异步请求
  * 启用浏览器缓存和文件压缩
  * CND加速
  * 建立独立的图片服务器

* **服务端优化**

  * 页面静态化

  * 并发处理

  * 队列处理

* **数据库优化**

  * 数据库缓存

  * 分库分表、分区操作

  * 读写分离

  * 负载均衡

* **web服务器优化**

  * Nginx负载均衡

### 3. 各方案具体说明

#### 3.1 防盗链

**盗链**：在自己的页面上展示一些不并在自己服务器上的内容

盗用大站的图片、音乐、视频。

**防盗链概念**：防止别人通过一些技术手段绕过本站的资源展示页面，盗用本站的资源，让绕开本站资源展示页面的资源链接失效。

可以大大减轻服务器及带宽的压力。

**工作原理**：通过Referer或者签名，网站可以检测目标网页访问的来源网址，如果是资源文件，则可以跟踪到显示它的网页地址。

一旦检测到来源不是本站即进行组织或者返回指定的页面

**Referer**：Nginx模块ngx_http_referer_module 用于阻挡来源非法的域名请求。Nignx指令valid_regerers，全局变量$invalid_referer

*valid_referers* none | blocked | server_names | string...;

none："Referer" 来源头部为空的情况

blocked："Referer" 来源头部不为空，但是里面的值被代理或者防火墙删除了，这些值都不以http://或者https://开头。

* 根据文件

```nginx
location ~.*\(gif|jpg|png|flv|swf|rar|zip)$
{
    valid_referers none blocked imooc.com *.imooc.com
    if ($invalid_referer)
    {
        #return 403;
        rewrite ^/http://www.imooc.com/403.jpg;     
    }        
}

```

* 根据目录

```nginx
location /images/
{
    valid_referers none blocked imooc.com *.imooc.com;
    if ($invalid_referer)
    {
       #return 4.3;
        rewrite ^/http://www.imooc.com/403.jpg;
    }
```

**传统防盗链遇到的问题**：伪造Referer

**解决**：可以使用加密签名解决

**使用**：使用第三方模块HttpAccessKeyModule实现Nginx防盗链

* accesskey on|off 模块开关
* accesskey_hashmethod md5 | sha-1签名加密方式

* accesskey_arg GET参数名称

* accesskey_signature 加密规则

```nginx
location ~.*\(gif|jpg|png|flv|swf|rar|zip)$
{
	accesskey on;
	accesskey_hashmethod md5;
    accesskey_arg "key";
    accesskey_signature "mypass$remote_addr";
}
```

```php
$key = md5('json', $_SERVER['REMOTE_ADDR']);
echo '<img src="./logo_new.png?key='.$key.'">'
```

#### 3.2 减少HTTP请求

**性能黄金法则**

只有10%-20%的最终用户响应时间花在接收请求的HTML文档上，剩下的80%-90%时间花在HTML文档所引用的所有组件进行的请求上。

**如何改善**

* **减少组件的数量**，从而减少HTTP的请求数量。

* **图片地图**：图片地图允许你在一个图片上关联多个URL。目标URL的选择取决于用户单击了图片上的哪个位置。

  ![image-20210302103731314](PHP面试分析.assets/image-20210302103731314.png)

* **CSS精灵**

* **合并脚本和样式表**：使用外部的js和css文件引用的方式，因为这要比直接写在页面中性能要更好一些。把多个js合并为一个js，把多个css合并为一个css。

* **图片使用Base64编码减少页面请求数**

**HTTP连接产生的开销**

* 域名解析->TCP连接->发送请求->等待->下载资源->解析时间

#### 3.3 浏览器缓存和数据压缩

* **HTTP缓存机制**

  * **缓存分类**

    * 200 from cache：直接从本地缓存中获取响应，最快速，最省浏览，因为根本没有向服务器发送请求。

    * 304 Not Modified：协商缓存，浏览器在本地缓存没有命中的情况下请求头中发送一定的校验数据到服务端，如果服务端数据没有改变浏览器从本地缓存响应，返回304。

      快速，发送的数据很少，只返回一些基本的响应头信息，数据量很小，不发送实际响应体。

    * 200 OK：以上两种缓存全部都失败，服务器返回完整响应。没有用到缓存，相对最慢。

  * **本地缓存**：浏览器认为本地缓存可以使用，不会去请求服务端。

* **本地缓存相关Header**

  * **Pragma**：HTTP1.0时代的遗留产物，该字段被设置为no-cache时，会告知浏览器禁用本地缓存，即每次都向服务器发送请求。

  * **Expires**：HTTP1.0时代用来启用本地缓存的字段，expires值对应一个形如THu, 31 Dec 2037 23:55:55 GMT的格林威治时间，告诉浏览器缓存实现的时刻，如果还没到该时刻，标明缓存有效，无需发送请求。
  * **Cache-Control**：HTTP1.1针对Expires时间不一致的解决方案，运用Cache-Control告知浏览器缓存过期的时间间隔而不是时刻，即使具体时间不一致，也不影响缓存的管理。
  * **优先级**：Pragma > Cache-Control > Expires

* **协商缓存相关Header**

  * **Last-Modified**：通知浏览器资源的最后修改时间

#### 3.4 CDN加速

* **什么是CDN**：
  * CDD的全称是Content Delivery Network，内容分发网络。
  * 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快，更稳定。
  * 在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络。
  * CDN系统能够实时地根据网络流量和各节点的连接，负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

* **使用CDN的优势**：
  * 本地Cache加速，提高了企业站点的访问速度。
  * 跨运营商的网络加速，保证不同网络的用户都能得到良好的访问质量。
  * 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器。
  * 自动生成服务器的远程Mirror cache服务器，远程用户访问从cache服务器上读取数据，减少远程访问你的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。
  * 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵。

* **CDN的工作原理：**
  * **传统访问**：用户在浏览器输入域名发起请求->解析域名获取服务器IP地址->根据IP地址找到对应的服务器->服务器响应并返回数据。
  * **使用CDN访问**：用户发起请求->智能DNS的解析(根据IP判断地理位置、接入网类型、选择路由最短和负载最轻的服务器)->取得缓存服务器IP->把内容返回给用户(如果缓存中有)->向源站发起请求->将结果返回给用户->将结果存入缓存服务器

* **CDN的适用场景：**
  * 站点或者应用中大量静态资源的加速分发，例如：CSS、JS、图片和HTML
  * 大文件下载
  * 直播网站

* **CDN的实现**：
  * BAT都有提供CDN服务
  * 可以LVS做4层负载均衡
  * 可用Nginx、Varnish、Squid、Apache、TrafficServer做7层负载均衡和cache
  * 使用squid反向代理，或者Nignx等的反向代理

#### 3.5 独立图片服务器

* **独立的必要性**

  * 分担Web服务器I/O负载-将耗费资源的图片服务分离出来，提高服务器的性能和稳定性。

  * 能够专门对图片服务器进行优化-为图片服务设置有针对性的缓存方案，减少带宽成本，提高访问速度

  * 提高网站的可扩展性-通过增加图片服务器，提高图片吞吐能力

* **采用独立域名**

  * 同一域名下浏览器的并发连接数有限制，突破浏览器连接数的限制
  * 由于cookie的原因，对缓存不利，大部分Web cache都只缓存不带cookies的请求，导致每次的图片请求都不能命中cache

* **独立后的问题**
  * **如何进行图片上传和图片同步**
    * NFS共享
    * 利用FTP同步

#### 3.6 动态语言静态化

* **什么是动态语言静态化**：

  * 将现有PHP等动态语言的逻辑代码生成为静态HTML文件，用户访问动态脚本重定向到静态HTML文件的过程。
  * 对实时性要求不高的页面

* **为什么要静态化**

  * 动态脚本通常会做逻辑计算和数据查询，访问量越大，服务器压力越大
  * 访问量大时可能会造成CPU负载过高，数据库服务器压力过大
  * 静态化可以奖励逻辑处理压力，降低数据库服务器查询压力

* **静态化的实现方式**

  * **使用模板引擎**

    可以使用Smarty的缓存机制生成静态HTML缓存文件

    * $smarty->cache_dir = $ROOT."/cache";	//缓存目录

    $smarty->caching = true; //是否开启缓存

    $smarty->cache_lifetime = "3600"; //缓存时间

    $smarty->display(string template[, string cache_id[, string compile_id]]);

    $smarty->clear_all_cache(); //清除所有缓存

    $smarty->clear_cache('file.html'); //清除指定的缓存

    $smarty->clear_cache('article.html', $art_id); //清除同一个模板下指定缓存号的缓存

  * **利用ob系列的函数**

    ob_start()：打开输出控制缓存

    ob_get_contents()：返回输出缓冲区内容

    ob_clean()：清空输出缓冲区

    ob_end_flush()：冲刷出(送出)输出缓冲区内容并关闭缓冲

  ```php
  <?php
  $cache_name = md5(__FILE__).'html';
  $cache_lifetime = 3600;
  
  if (filectime(__FILE__) <= filectime($cache_name) && file_exists($cache_name) && filectime($cache_name) + $cache_lifetime > time())
  {
      include $cache_name;
      exit;
  }
  ob_start();
  ?>
  <b>THIS IS MY SCRIPT</b>
  <?php
  $content = ob_get_contents();
  ob_end_flush();
  
  $handle = fopen($cache_name, 'w');
  fwrite($handle, $content);
  fclose($handle);
  ?>
  ```

#### 3.7 动态语言的并发处理

* **什么是进程、线程、协程**

  * 进程：是动态的，是程序一次执行的过程。是资源分配的基本单位
  * 线程：是独立调度的基本单位
  * 协程：是一种用户态的轻量级线程，协程的调度完全有由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

* **什么是多进程、多线程**

  * 多进程：同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这就是多进程。

  * 多线程：是把一个仅分成很多片，每一片都可以是一个独立的流程。与多进程的区别是只会使用一个进程的资源，线程间可以直接通信。
  * 举例：
    * 单进程单线程：一个人在一个桌子上吃菜
    * 单进程多线程：多个人在同一个桌子上一起吃菜
    * 多进程单线程：多个人每个人在自己的桌子上吃菜

* **同步阻塞模型**

  * 多进程：最早的服务器段程序都是通过多进程、多线程来解决并发IO的问题。一个请求创建一个进程，然后子进程进入循环同步阻塞地与客户端连接进行交互，收发处理数据
  * 多线程：用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据
  * 步骤
    * 创建一个socket，进入while循环，阻塞进程accept操作上，等待客户端连接进入
    * 主进程在多进程模型下通过fork创建子进程
    * 多线程模型下可以创建子线程子
    * 子进程/线程创建成功后进入while循环，阻塞在recv调用上，等待客户端向服务器发送。
    * 收到数据后服务器程序进行处理然后使用send向客户端发送响应