## 传输层

网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，是应用程序看起来像是在两个传输层实体之间有一条短刀端的逻辑通信信道

### 1. UDP和TCP的特点

💦 **用户数据报协议 UDP**（User Datagram Protocol）

* **UDP 在传输数据之前不需要建立连接**，尽最大可能交付，没有拥塞控制，面向报文(对于应用进程传下来的报文不合并也不拆分，只是添加UDP首部)，支持一对一，一对多、多对一和多对多的交互通信。

* 虽然UDP**不提供可靠传输**，但是在某些情况下UDP却是一个中最有效的工作方式。(一般用于即时通信)

💦 **传输控制协议 TCP**（Transmission Control Protocol）：

* TCP是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双共通信，面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)，每一条TCP连接只能是点对点的 (一对一)。
* TCP**一般用于文件传输、发送和接受邮件、远程登录等场景**

### 2. UDP首部格式

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" style="zoom:50%;" />

首部字段只有8字节，包括源端口、目的端口、长度、检验和。12字节的伪首部是为了计算检验和临时添加的。

### 3. TCP首部格式

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom:50%;" />

* **源端口和目的端口**：各占2个字节，分别写入源端口和目的端口。IP地址 + 端口号就可以确定一个进程地址。

* **序号**(sn)：用于对字节流进行编号，例如序号为301，表示第一个字节的编号为301，如果携带的数据长度为100字节，那么下一个报文段的序号应为401。
* **确认号**(ack)：期望收到的下一个报文的序号。例如B正确收到A发送来的一个报文段，序号为501，携带的数据长度为200字节，因此B期望下一个报文段的序号为701，B发送给A的确认报文段中确认号就为701。
* **数据偏移**：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
* **保留**：占6位，置为0，保留为今后使用。
* **紧急 URG**： 当URG = 1时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制需配合紧急指针使用(紧急指针指出苯保温段中紧急数据的字节数)
* **确认 ACK**：当ACK=1时确认号字段有效，否则无效。TCP规定，在连接建立后所发送的报文段都必须把ACK置为1。
* **推送 PSH**：当PSH = 1时，并立即创建一个报文发送出去。接收方TCP收到PSH = 1的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满后再向上交付。
* **复位 RST**：当RST = 1时，表明TCP连接中出现了严重那错误(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立传输连接。
* **同步 SYN**：在连接建立时用来同步序号。当SYN = 1，ACK = 0时表示这是一个连接请求报文段。若对方同意建立连接，则相应报文中SYN = 1， ACK = 1。
* **终止 FIN**：用来释放一个连接，当FIN = 1时，表示此报文段的发送方的数据已经发送完毕，并要求释放连接。
* **窗口**：窗口值作为接收方让发送方设置其窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

### 4. TCP的三次握手

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom:50%;" />

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的**初始化序列号(ISN)**为后面的可靠性传输做准备。

假设A为客户端，B为服务器段。

**刚开始客户端处于Closed状态，而服务端处于Listen状态**

> CLOSED：没有任何连接状态
>
> LISTEN：侦听来自远方TCP端口的连接请求

* **第一次握手**：A向B发送一个SYN报文， SYN = 1， seq = x，表示本报文所发送的数据的第一个字节的序号。此时A处于同步发送状态。

  > SYN-SENT：在发送连接请求后等待匹配的连接请求

* **第二次握手**：B收到A的SYN报文之后，会发送SYN报文作为应答, SYN = 1, ACK = 1, seq = y, ack = x + 1,此时B处于同步接收状态。

  > SYN-RECEUVED：在收到和发送一个连接请求后等待对连接请求的确认

* **第三次握手**：A收到B的响应SYN报文后，会发送ACK确认报文，ACK = 1， seq = x + 1, ack = y + 1，此时A处于连接建立状态。

  B收到ACK报文之后，也处于连接建立状态，至此，双方建立起来了TCP连接

  > ESTABLISHED：代表一个打开的连接，数据可以传送用户

#### ① 三次握手的原因

> 三次握手的目的是建立可靠的通信信道，而三次握手最主要的目的就是双方确认自己与对方的放松与接收是否正常。

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开链接

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。造成资源的浪费。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开链接。

#### ② ISN (Initial Sequence Number) 是固定的吗

**三次握手的其中一个重要功能是客户端和服务器端交换ISN(Initial Sequence Number),以便让对方知道接下来接受数据的时候如何按序列号组装数据。**

当一端为建立连接而发送它的SYN时，它会为连接选择一个初始化序列号。ISN随时间而变化，因此每个连接都将具有不同的ISN。**如果ISN是固定的，攻击者容易猜出后续的确认号，因此ISN是动态生成的**

#### ③ 三次握手过程中可以携带数据吗

第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手绝对不可以携带数据**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手的SYN报文中放入大量的数据，然后疯狂重复发送SYN报文的话，这会让服务器花费大量的时间和内存空间来接收处理这个报文。

⭐**请求连接/接受 即SYN = 1的时候不能携带数据**

而对于第三次的话，次时客户端已经处于ESTABLISHED状态。对于客户端来说，它已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以可以正常发送、携带数据。

#### ④ 半连接队列

服务器第一次收到客户端的SYN之后，就会处于SYN_RCVD状态，此时双方还没有完全建立起连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。

**全连接队列**，完成三次握手后建立起的连接就会放在全连接队列中，如果队列满了就有可能会出现丢包的现象。

#### ⑤ SYN洪泛攻击

SYN攻击就是**Client 在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，** Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用半连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞设置系统瘫痪。

#### ⑥ 如果第三次握手丢失了，客户端服务端会如何处理

服务器发送完SYN-ACK包，如果为收到客户端响应的确认包，也即第三次握手丢失。那么服务器就会进行首次重传，若等待一端时间仍未收到客户确认包，就进行第二次重传。如果重传次数超过系统规定的最大重传次数，则系统将改连接信息从班连接队列中删除。

注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为1s，2s，4s，8s...

### 4. TCP的四次挥手



<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom: 67%;" />

刚开始双方都处于连接建立状态，假设是客户端先发起关闭请求。四次挥手的过程如下：

* **第一次挥手**：A发送一个请求终止报文，FIN = 1，seq = u。并停止再发送数据，主动关闭TCP连接。此时A处于终止等待-1状态，等待B的确认。

  > FIN-WATI-1 -等待远程TCP的连接中断请求，或先前的连接中断请求的确认。

* **第二次挥手**：B收到FIN后，会发送ACK确认报文，ACK = 1， seq = v, ack = u + 1,表明已经收到客户端的报文，此时B处于关闭等待状态。

  > CLOSE-WAIT -等待从本地用户发来的连接中断请求。

  **此时的TCP处于半关闭状态，A到B的连接释放。** A收到B的确认后，进入终止等待2状态，等待B发出的连接释放报文。

  > FIN-WAIT-2 -从远程TCP等待连接中断请求

* **第三次挥手**：如果B也想断开连接了(没有向A发送数据)，和A第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务器处于最后确认状态，等待A的确认。

  > LAST-ACK-等待原来向远程TCP的连接中断请求的确认

* **第四次挥手**：A收到FIN后，一样发送一个ACK报文作为应答， ACK = 1，seq = u + 1, ack = w + 1,此时A处于时间等待状态

  > TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认

  🚨 notice！！！这时候B到A的TCP连接并未释放掉，**需要经过等待计时器设置的时间2MSL(报文最大生存周期)后才会进入关闭状态**

  目的：确保B收到ACK报文。如果B端在规定时间内没有收到A发来的ACK报文的话，B会重新发送FIN报文给A，如果A没有时间等待状态而直接关闭，那么B将会一直发送释放连接的报文，从而浪费网络资源。

#### ① 为什么要四次挥手

由于TCP的**半关闭**(half-close)特性，TCP提供了连接的一端在结束它的发送后还能接受来自另一端数据的能力。

任何一方都可以在数据传送结束后发出连接释放 的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放的通知，对方确认后就**完全关闭**了TCP连接。

**通俗来说，两次握手就可以释放到另一端的TCP连接，完全释放连接一共需要四次握手**

### 5. 参考资料

* [CYC2018](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html)
* [飞天小牛肉](https://juejin.cn/post/6915024149203288072)