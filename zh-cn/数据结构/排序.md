## 1. 排序

### 1.1 什么是排序？

> 将一组杂乱无章的数据按一定规律顺次排列起来。即将无序序列排成一个有序序列(由小到大或由大到小)的运算。

* 如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。

* 排序的应用非常广泛：磁盘目录、电商网站商品排序、游戏排行榜等

### 1.2 排序的分类

 **按数据存储介质**： 内部排序和外部排序

**按比较器个数**：串行排序和并行排序

**按主要操作**：比较排序和基数排序

**按辅助空间**：原地排序和非原地排序

**按稳定性**：稳定排序和非稳定排序

**按自然性**：自然排序和非自然排序

**按存储介质可分为**

* 外部排序：数据量不大、数据在内存，无需内外存交换数据
* 外部排序：数据量较大、数据在外存 (文件排序)

* 按比较器个数可分为
  * 串行排序：单处理机 (同一时刻比较一对元素)
  * 并行排序：多处理机 (同一时刻比较多对元素)
* 比较排序：用比较的方法
  * 插入排序
  * 交换排序
  * 选择排序
  * 归并排序
* 基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

**按辅助空间可分为**

* 原地排序：辅助空间用量为O(1)的排序方法
* 非原地排序：辅助空间用量超过O(1)的排序方法

**按稳定性可分为**

* 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
* 非稳定排序：不是稳定排序的方法
* 排序的稳定性只对*结构类型数据* 排序有意义

**按自然性可分为**

* 自然排序：输入数据越有序，排序的速度越快的排序方法
* 非自然排序：不是自然排序的方法

**按排序依据原则**

* 插入排序：直接插入排序、折半插入排序、希尔排序
* 交换排序：冒泡排序、快速排序
* 选择排序：简单选择排序、堆排序
* 归并排序：2-路归并排序
* 基数排序

**按排序所需工作量**

* 简单的排序方法：T(n) = O(n^2)
* 基数排序：T(n) = O(d.n)
* 先进的排序方法：T(n) = O(nlogn)

## 2. 排序代码实现

### 2.1 插入排序

**基本思想**：每步将一个待排序的对象，按其关键码大小，插入到前面已经排序好的一组对象的适当位置上，直到对象全部插入为止

**特点**：边插入边排序，保证子序列中随时都是排序好的

#### ① 直接插入排序

* **直接插入排序--采用 *顺序查找* 法查找插入为止**

* **动画演示**：

  ![img](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

* **代码实现**

```c
// Created by Mr Cheng

#include <iostream>
using namespace std;

//不带哨兵
void insertSort(int *arr, int len)
{
    for (int i = 1; i < len; i++)
    {
        int key = arr[i];
        int j = i - 1;
        while ((j >= 0) && key < arr[j])
        {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

int main()
{
    int arr[8] = {1, 4, 3, 8, 7, 2, 6, 0};
    insertSort(arr, 8);
    for (int i = 0; i < 8 ; ++i)
        cout << arr[i] << " ";
    return 0;
}
```

```c
// Created by Mr Cheng

#include <iostream>
using namespace std;

//带哨兵
void insertSort_2(int *arr, int len)
{
    int i, j;
    for (i = 2; i <= len; i++)
    {
        if (arr[i] < arr[i - 1])
        {
            arr[0] = arr[i];
            for (j = i - 1; arr[0] < arr[j]; j--)
            {
                arr[j + 1] = arr[j];
            }
            arr[j + 1] = arr[0];
        }
    }
}

int main()
{
    int arr[9] = {0, 1, 4, 3, 8, 7, 2, 6, 0}; //arr[0]作为哨兵
    insertSort_2(arr, 8);
    for (int i = 1; i < 9 ; ++i)
        cout << arr[i] << " ";
    return 0;
}
```

**性能分析**

* 最好情况(顺序有序)
  * 比较次数： n - 1
  * 移动次数：0
* 最差情况(逆序)
  * 比较次数：(n + 2)(n - 1) / 2
  * 移动次数：(n + 4)(n - 1) / 2

* 平均情况
  * 比较次数：(n + 2)(n - 1) / 4
  * 移动次数：(n + 6)(n - 1) / 4

**时间复杂度**

* 原始数据越接近有序，排序速度越快
* 最坏情况(逆序) O(n^2)
* 最好情况(顺序) O(n)
* 平均情况 O(n^2)
* 要提高查找速度
  * 减少元素的比较次数
  * 减少元素的移动次数

**空间复杂度**

* O(1)

**稳定性**

* 稳定

#### ② 折半插入排序

* 代码实现

```c
// Created by Mr Cheng

#include <iostream>
using namespace std;

//折半插入排序
void BInsertSort(int *arr, int len)
{
    int i, j;
    for (i = 2; i <= len; i++)
    {
        arr[0] = arr[i];
        int low = 1, high = i - 1;
        while (low <= high)
        {
            int mid = low + high >> 1;
            if (arr[0] < arr[mid]) high = mid - 1;
            else low = mid + 1;
        }
        for (j = i - 1; j >= high + 1; j--) arr[j + 1] = arr[j];
        arr[high + 1] = arr[0];
    }
}

int main()
{
    int arr[9] = {0, 1, 4, 3, 8, 7, 2, 6, 0};
    BInsertSort(arr, 8);
    for (int i = 1; i < 9 ; ++i)
        cout << arr[i] << " ";
    return 0;
}
```

**性能分析**

* 折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入要快
* 它所需要的关键吗比较与待排序对象序列的初始排序无关，仅依赖于对象个数
* 减少了比较次数，但没有减少移动次数
* 平均性能优于直接插入排序
* 时间复杂度为 O(n^2)
* 空间复杂度为 O(1)
* 稳定性：稳定

#### ③ 希尔排序④⑤⑥⑦⑧⑨

